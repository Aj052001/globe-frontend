"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/three-geojson-geometry";
exports.ids = ["vendor-chunks/three-geojson-geometry"];
exports.modules = {

/***/ "(ssr)/./node_modules/three-geojson-geometry/dist/three-geojson-geometry.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/three-geojson-geometry/dist/three-geojson-geometry.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GeoJsonGeometry: () => (/* binding */ GeoJsonGeometry)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var earcut__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! earcut */ \"(ssr)/./node_modules/earcut/src/earcut.js\");\n/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-geo */ \"(ssr)/./node_modules/d3-geo/src/distance.js\");\n/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-geo */ \"(ssr)/./node_modules/d3-geo/src/interpolate.js\");\n\n\n\n\nfunction _arrayLikeToArray(r, a) {\n  (null == a || a > r.length) && (a = r.length);\n  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];\n  return n;\n}\nfunction _arrayWithHoles(r) {\n  if (Array.isArray(r)) return r;\n}\nfunction _assertThisInitialized(e) {\n  if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return e;\n}\nfunction _callSuper(t, o, e) {\n  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _classCallCheck(a, n) {\n  if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n}\nfunction _createClass(e, r, t) {\n  return Object.defineProperty(e, \"prototype\", {\n    writable: !1\n  }), e;\n}\nfunction _createForOfIteratorHelper(r, e) {\n  var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (!t) {\n    if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e) {\n      t && (r = t);\n      var n = 0,\n        F = function () {};\n      return {\n        s: F,\n        n: function () {\n          return n >= r.length ? {\n            done: !0\n          } : {\n            done: !1,\n            value: r[n++]\n          };\n        },\n        e: function (r) {\n          throw r;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var o,\n    a = !0,\n    u = !1;\n  return {\n    s: function () {\n      t = t.call(r);\n    },\n    n: function () {\n      var r = t.next();\n      return a = r.done, r;\n    },\n    e: function (r) {\n      u = !0, o = r;\n    },\n    f: function () {\n      try {\n        a || null == t.return || t.return();\n      } finally {\n        if (u) throw o;\n      }\n    }\n  };\n}\nfunction _getPrototypeOf(t) {\n  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {\n    return t.__proto__ || Object.getPrototypeOf(t);\n  }, _getPrototypeOf(t);\n}\nfunction _inherits(t, e) {\n  if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n  t.prototype = Object.create(e && e.prototype, {\n    constructor: {\n      value: t,\n      writable: !0,\n      configurable: !0\n    }\n  }), Object.defineProperty(t, \"prototype\", {\n    writable: !1\n  }), e && _setPrototypeOf(t, e);\n}\nfunction _isNativeReflectConstruct() {\n  try {\n    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n  } catch (t) {}\n  return (_isNativeReflectConstruct = function () {\n    return !!t;\n  })();\n}\nfunction _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = !0,\n      o = !1;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) {\n        if (Object(t) !== t) return;\n        f = !1;\n      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = !0, n = r;\n    } finally {\n      try {\n        if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _possibleConstructorReturn(t, e) {\n  if (e && (\"object\" == typeof e || \"function\" == typeof e)) return e;\n  if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\");\n  return _assertThisInitialized(t);\n}\nfunction _setPrototypeOf(t, e) {\n  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {\n    return t.__proto__ = e, t;\n  }, _setPrototypeOf(t, e);\n}\nfunction _slicedToArray(r, e) {\n  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();\n}\nfunction _unsupportedIterableToArray(r, a) {\n  if (r) {\n    if (\"string\" == typeof r) return _arrayLikeToArray(r, a);\n    var t = {}.toString.call(r).slice(8, -1);\n    return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;\n  }\n}\n\nvar interpolateLine = function interpolateLine() {\n  var lineCoords = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var maxDegDistance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var result = [];\n  var prevPnt = null;\n  lineCoords.forEach(function (pnt) {\n    if (prevPnt) {\n      var dist = (0,d3_geo__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(pnt, prevPnt) * 180 / Math.PI;\n      if (dist > maxDegDistance) {\n        var interpol = (0,d3_geo__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(prevPnt, pnt);\n        var tStep = 1 / Math.ceil(dist / maxDegDistance);\n        var t = tStep;\n        while (t < 1) {\n          result.push(interpol(t));\n          t += tStep;\n        }\n      }\n    }\n    result.push(prevPnt = pnt);\n  });\n  return result;\n};\n\nvar THREE = typeof window !== 'undefined' && window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  BufferGeometry: three__WEBPACK_IMPORTED_MODULE_3__.BufferGeometry,\n  Float32BufferAttribute: three__WEBPACK_IMPORTED_MODULE_3__.Float32BufferAttribute\n};\n\n// support both modes for backwards threejs compatibility\nvar setAttributeFn = new THREE.BufferGeometry().setAttribute ? 'setAttribute' : 'addAttribute';\nvar GeoJsonGeometry = /*#__PURE__*/function (_THREE$BufferGeometry) {\n  function GeoJsonGeometry(geoJson) {\n    var _this;\n    var radius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    var resolution = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 5;\n    _classCallCheck(this, GeoJsonGeometry);\n    _this = _callSuper(this, GeoJsonGeometry);\n    _this.type = 'GeoJsonGeometry';\n    _this.parameters = {\n      geoJson: geoJson,\n      radius: radius,\n      resolution: resolution\n    };\n\n    // process various geometry types\n    var groups = ({\n      Point: genPoint,\n      MultiPoint: genMultiPoint,\n      LineString: genLineString,\n      MultiLineString: genMultiLineString,\n      Polygon: genPolygon,\n      MultiPolygon: genMultiPolygon\n    }[geoJson.type] || function () {\n      return [];\n    })(geoJson.coordinates, radius);\n\n    // concat groups\n    var indices = [],\n      vertices = [];\n    var groupCnt = 0;\n    groups.forEach(function (newG) {\n      var prevIndCnt = indices.length;\n      concatGroup({\n        indices: indices,\n        vertices: vertices\n      }, newG);\n      _this.addGroup(prevIndCnt, indices.length - prevIndCnt, groupCnt++);\n    });\n\n    // build geometry\n    indices.length && _this.setIndex(indices);\n    vertices.length && _this[setAttributeFn]('position', new THREE.Float32BufferAttribute(vertices, 3));\n\n    //\n\n    function genPoint(coords, r) {\n      var vertices = polar2Cartesian(coords[1], coords[0], r);\n      var indices = [];\n      return [{\n        vertices: vertices,\n        indices: indices\n      }];\n    }\n    function genMultiPoint(coords, r) {\n      var result = {\n        vertices: [],\n        indices: []\n      };\n      coords.map(function (c) {\n        return genPoint(c, r);\n      }).forEach(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 1),\n          newPnt = _ref2[0];\n        concatGroup(result, newPnt);\n      });\n      return [result];\n    }\n    function genLineString(coords, r) {\n      var coords3d = interpolateLine(coords, resolution).map(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n          lng = _ref4[0],\n          lat = _ref4[1];\n        return polar2Cartesian(lat, lng, r);\n      });\n      var _earcutFlatten = (0,earcut__WEBPACK_IMPORTED_MODULE_0__.flatten)([coords3d]),\n        vertices = _earcutFlatten.vertices;\n      var numPoints = Math.round(vertices.length / 3);\n      var indices = [];\n      for (var vIdx = 1; vIdx < numPoints; vIdx++) {\n        indices.push(vIdx - 1, vIdx);\n      }\n      return [{\n        vertices: vertices,\n        indices: indices\n      }];\n    }\n    function genMultiLineString(coords, r) {\n      var result = {\n        vertices: [],\n        indices: []\n      };\n      coords.map(function (c) {\n        return genLineString(c, r);\n      }).forEach(function (_ref5) {\n        var _ref6 = _slicedToArray(_ref5, 1),\n          newLine = _ref6[0];\n        concatGroup(result, newLine);\n      });\n      return [result];\n    }\n    function genPolygon(coords, r) {\n      var coords3d = coords.map(function (coordsSegment) {\n        return interpolateLine(coordsSegment, resolution).map(function (_ref7) {\n          var _ref8 = _slicedToArray(_ref7, 2),\n            lng = _ref8[0],\n            lat = _ref8[1];\n          return polar2Cartesian(lat, lng, r);\n        });\n      });\n\n      // Each point generates 3 vertice items (x,y,z).\n      var _earcutFlatten2 = (0,earcut__WEBPACK_IMPORTED_MODULE_0__.flatten)(coords3d),\n        vertices = _earcutFlatten2.vertices,\n        holes = _earcutFlatten2.holes;\n      var firstHoleIdx = holes[0] || Infinity;\n      var outerVertices = vertices.slice(0, firstHoleIdx * 3);\n      var holeVertices = vertices.slice(firstHoleIdx * 3);\n      var holesIdx = new Set(holes);\n      var numPoints = Math.round(vertices.length / 3);\n      var outerIndices = [],\n        holeIndices = [];\n      for (var vIdx = 1; vIdx < numPoints; vIdx++) {\n        if (!holesIdx.has(vIdx)) {\n          if (vIdx < firstHoleIdx) {\n            outerIndices.push(vIdx - 1, vIdx);\n          } else {\n            holeIndices.push(vIdx - 1 - firstHoleIdx, vIdx - firstHoleIdx);\n          }\n        }\n      }\n      var groups = [{\n        indices: outerIndices,\n        vertices: outerVertices\n      }];\n      if (holes.length) {\n        groups.push({\n          indices: holeIndices,\n          vertices: holeVertices\n        });\n      }\n      return groups;\n    }\n    function genMultiPolygon(coords, r) {\n      var outer = {\n        vertices: [],\n        indices: []\n      };\n      var holes = {\n        vertices: [],\n        indices: []\n      };\n      coords.map(function (c) {\n        return genPolygon(c, r);\n      }).forEach(function (_ref9) {\n        var _ref10 = _slicedToArray(_ref9, 2),\n          newOuter = _ref10[0],\n          newHoles = _ref10[1];\n        concatGroup(outer, newOuter);\n        newHoles && concatGroup(holes, newHoles);\n      });\n      var groups = [outer];\n      holes.vertices.length && groups.push(holes);\n      return groups;\n    }\n    return _this;\n  }\n  _inherits(GeoJsonGeometry, _THREE$BufferGeometry);\n  return _createClass(GeoJsonGeometry);\n}(THREE.BufferGeometry); //\nfunction concatGroup(main, extra) {\n  var prevVertCnt = Math.round(main.vertices.length / 3);\n  concatArr(main.vertices, extra.vertices);\n  concatArr(main.indices, extra.indices.map(function (ind) {\n    return ind + prevVertCnt;\n  }));\n}\nfunction concatArr(target, src) {\n  var _iterator = _createForOfIteratorHelper(src),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var e = _step.value;\n      target.push(e);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}\nfunction polar2Cartesian(lat, lng) {\n  var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var phi = (90 - lat) * Math.PI / 180;\n  var theta = (90 - lng) * Math.PI / 180;\n  return [r * Math.sin(phi) * Math.cos(theta),\n  // x\n  r * Math.cos(phi),\n  // y\n  r * Math.sin(phi) * Math.sin(theta) // z\n  ];\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtZ2VvanNvbi1nZW9tZXRyeS9kaXN0L3RocmVlLWdlb2pzb24tZ2VvbWV0cnkubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQStEO0FBQzlCO0FBQ29COztBQUVyRDtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RjtBQUN6RixJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFlBQVksa0VBQWtFO0FBQ3RGLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtEQUFXO0FBQzVCO0FBQ0EsdUJBQXVCLGtEQUFjO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsaURBQWM7QUFDaEMsMEJBQTBCLHlEQUFzQjtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsMkJBQTJCLCtDQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixrQkFBa0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBLDRCQUE0QiwrQ0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsa0JBQWtCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw4QkFBOEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTJCIiwic291cmNlcyI6WyIvaG9tZS9hamF5LXNpbmdoL0Rlc2t0b3AvZ2xvYmUtYWpheS9HbG9iYWwtSG91c2UtQWN0aXZpdHkvZ2xvYmUvbm9kZV9tb2R1bGVzL3RocmVlLWdlb2pzb24tZ2VvbWV0cnkvZGlzdC90aHJlZS1nZW9qc29uLWdlb21ldHJ5Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCdWZmZXJHZW9tZXRyeSwgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gJ3RocmVlJztcbmltcG9ydCB7IGZsYXR0ZW4gfSBmcm9tICdlYXJjdXQnO1xuaW1wb3J0IHsgZ2VvRGlzdGFuY2UsIGdlb0ludGVycG9sYXRlIH0gZnJvbSAnZDMtZ2VvJztcblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkociwgYSkge1xuICAobnVsbCA9PSBhIHx8IGEgPiByLmxlbmd0aCkgJiYgKGEgPSByLmxlbmd0aCk7XG4gIGZvciAodmFyIGUgPSAwLCBuID0gQXJyYXkoYSk7IGUgPCBhOyBlKyspIG5bZV0gPSByW2VdO1xuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHIpKSByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoZSkge1xuICBpZiAodm9pZCAwID09PSBlKSB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gX2NhbGxTdXBlcih0LCBvLCBlKSB7XG4gIHJldHVybiBvID0gX2dldFByb3RvdHlwZU9mKG8pLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBbXSwgX2dldFByb3RvdHlwZU9mKHQpLmNvbnN0cnVjdG9yKSA6IG8uYXBwbHkodCwgZSkpO1xufVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGEsIG4pIHtcbiAgaWYgKCEoYSBpbnN0YW5jZW9mIG4pKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKGUsIHIsIHQpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcInByb3RvdHlwZVwiLCB7XG4gICAgd3JpdGFibGU6ICExXG4gIH0pLCBlO1xufVxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIociwgZSkge1xuICB2YXIgdCA9IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiByW1N5bWJvbC5pdGVyYXRvcl0gfHwgcltcIkBAaXRlcmF0b3JcIl07XG4gIGlmICghdCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHIpIHx8ICh0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIpKSB8fCBlKSB7XG4gICAgICB0ICYmIChyID0gdCk7XG4gICAgICB2YXIgbiA9IDAsXG4gICAgICAgIEYgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHM6IEYsXG4gICAgICAgIG46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gbiA+PSByLmxlbmd0aCA/IHtcbiAgICAgICAgICAgIGRvbmU6ICEwXG4gICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgIGRvbmU6ICExLFxuICAgICAgICAgICAgdmFsdWU6IHJbbisrXVxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGU6IGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgdGhyb3cgcjtcbiAgICAgICAgfSxcbiAgICAgICAgZjogRlxuICAgICAgfTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xuICB9XG4gIHZhciBvLFxuICAgIGEgPSAhMCxcbiAgICB1ID0gITE7XG4gIHJldHVybiB7XG4gICAgczogZnVuY3Rpb24gKCkge1xuICAgICAgdCA9IHQuY2FsbChyKTtcbiAgICB9LFxuICAgIG46IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciByID0gdC5uZXh0KCk7XG4gICAgICByZXR1cm4gYSA9IHIuZG9uZSwgcjtcbiAgICB9LFxuICAgIGU6IGZ1bmN0aW9uIChyKSB7XG4gICAgICB1ID0gITAsIG8gPSByO1xuICAgIH0sXG4gICAgZjogZnVuY3Rpb24gKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYSB8fCBudWxsID09IHQucmV0dXJuIHx8IHQucmV0dXJuKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAodSkgdGhyb3cgbztcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YodCkge1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIHQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZih0KTtcbiAgfSwgX2dldFByb3RvdHlwZU9mKHQpO1xufVxuZnVuY3Rpb24gX2luaGVyaXRzKHQsIGUpIHtcbiAgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgZSAmJiBudWxsICE9PSBlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShlICYmIGUucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiB0LFxuICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgIH1cbiAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcInByb3RvdHlwZVwiLCB7XG4gICAgd3JpdGFibGU6ICExXG4gIH0pLCBlICYmIF9zZXRQcm90b3R5cGVPZih0LCBlKTtcbn1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gIHRyeSB7XG4gICAgdmFyIHQgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICB9IGNhdGNoICh0KSB7fVxuICByZXR1cm4gKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICEhdDtcbiAgfSkoKTtcbn1cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBsKSB7XG4gIHZhciB0ID0gbnVsbCA9PSByID8gbnVsbCA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiByW1N5bWJvbC5pdGVyYXRvcl0gfHwgcltcIkBAaXRlcmF0b3JcIl07XG4gIGlmIChudWxsICE9IHQpIHtcbiAgICB2YXIgZSxcbiAgICAgIG4sXG4gICAgICBpLFxuICAgICAgdSxcbiAgICAgIGEgPSBbXSxcbiAgICAgIGYgPSAhMCxcbiAgICAgIG8gPSAhMTtcbiAgICB0cnkge1xuICAgICAgaWYgKGkgPSAodCA9IHQuY2FsbChyKSkubmV4dCwgMCA9PT0gbCkge1xuICAgICAgICBpZiAoT2JqZWN0KHQpICE9PSB0KSByZXR1cm47XG4gICAgICAgIGYgPSAhMTtcbiAgICAgIH0gZWxzZSBmb3IgKDsgIShmID0gKGUgPSBpLmNhbGwodCkpLmRvbmUpICYmIChhLnB1c2goZS52YWx1ZSksIGEubGVuZ3RoICE9PSBsKTsgZiA9ICEwKTtcbiAgICB9IGNhdGNoIChyKSB7XG4gICAgICBvID0gITAsIG4gPSByO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIWYgJiYgbnVsbCAhPSB0LnJldHVybiAmJiAodSA9IHQucmV0dXJuKCksIE9iamVjdCh1KSAhPT0gdSkpIHJldHVybjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChvKSB0aHJvdyBuO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYTtcbiAgfVxufVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIGUpIHtcbiAgaWYgKGUgJiYgKFwib2JqZWN0XCIgPT0gdHlwZW9mIGUgfHwgXCJmdW5jdGlvblwiID09IHR5cGVvZiBlKSkgcmV0dXJuIGU7XG4gIGlmICh2b2lkIDAgIT09IGUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTtcbiAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQodCk7XG59XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YodCwgZSkge1xuICByZXR1cm4gX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgcmV0dXJuIHQuX19wcm90b19fID0gZSwgdDtcbiAgfSwgX3NldFByb3RvdHlwZU9mKHQsIGUpO1xufVxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkociwgZSkge1xuICByZXR1cm4gX2FycmF5V2l0aEhvbGVzKHIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBlKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkociwgZSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpO1xufVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIsIGEpIHtcbiAgaWYgKHIpIHtcbiAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgcikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KHIsIGEpO1xuICAgIHZhciB0ID0ge30udG9TdHJpbmcuY2FsbChyKS5zbGljZSg4LCAtMSk7XG4gICAgcmV0dXJuIFwiT2JqZWN0XCIgPT09IHQgJiYgci5jb25zdHJ1Y3RvciAmJiAodCA9IHIuY29uc3RydWN0b3IubmFtZSksIFwiTWFwXCIgPT09IHQgfHwgXCJTZXRcIiA9PT0gdCA/IEFycmF5LmZyb20ocikgOiBcIkFyZ3VtZW50c1wiID09PSB0IHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KHQpID8gX2FycmF5TGlrZVRvQXJyYXkociwgYSkgOiB2b2lkIDA7XG4gIH1cbn1cblxudmFyIGludGVycG9sYXRlTGluZSA9IGZ1bmN0aW9uIGludGVycG9sYXRlTGluZSgpIHtcbiAgdmFyIGxpbmVDb29yZHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuICB2YXIgbWF4RGVnRGlzdGFuY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDE7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIHByZXZQbnQgPSBudWxsO1xuICBsaW5lQ29vcmRzLmZvckVhY2goZnVuY3Rpb24gKHBudCkge1xuICAgIGlmIChwcmV2UG50KSB7XG4gICAgICB2YXIgZGlzdCA9IGdlb0Rpc3RhbmNlKHBudCwgcHJldlBudCkgKiAxODAgLyBNYXRoLlBJO1xuICAgICAgaWYgKGRpc3QgPiBtYXhEZWdEaXN0YW5jZSkge1xuICAgICAgICB2YXIgaW50ZXJwb2wgPSBnZW9JbnRlcnBvbGF0ZShwcmV2UG50LCBwbnQpO1xuICAgICAgICB2YXIgdFN0ZXAgPSAxIC8gTWF0aC5jZWlsKGRpc3QgLyBtYXhEZWdEaXN0YW5jZSk7XG4gICAgICAgIHZhciB0ID0gdFN0ZXA7XG4gICAgICAgIHdoaWxlICh0IDwgMSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGludGVycG9sKHQpKTtcbiAgICAgICAgICB0ICs9IHRTdGVwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKHByZXZQbnQgPSBwbnQpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciBUSFJFRSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5USFJFRSA/IHdpbmRvdy5USFJFRSAvLyBQcmVmZXIgY29uc3VtcHRpb24gZnJvbSBnbG9iYWwgVEhSRUUsIGlmIGV4aXN0c1xuOiB7XG4gIEJ1ZmZlckdlb21ldHJ5OiBCdWZmZXJHZW9tZXRyeSxcbiAgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZTogRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZVxufTtcblxuLy8gc3VwcG9ydCBib3RoIG1vZGVzIGZvciBiYWNrd2FyZHMgdGhyZWVqcyBjb21wYXRpYmlsaXR5XG52YXIgc2V0QXR0cmlidXRlRm4gPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKS5zZXRBdHRyaWJ1dGUgPyAnc2V0QXR0cmlidXRlJyA6ICdhZGRBdHRyaWJ1dGUnO1xudmFyIEdlb0pzb25HZW9tZXRyeSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1RIUkVFJEJ1ZmZlckdlb21ldHJ5KSB7XG4gIGZ1bmN0aW9uIEdlb0pzb25HZW9tZXRyeShnZW9Kc29uKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIHZhciByYWRpdXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDE7XG4gICAgdmFyIHJlc29sdXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDU7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEdlb0pzb25HZW9tZXRyeSk7XG4gICAgX3RoaXMgPSBfY2FsbFN1cGVyKHRoaXMsIEdlb0pzb25HZW9tZXRyeSk7XG4gICAgX3RoaXMudHlwZSA9ICdHZW9Kc29uR2VvbWV0cnknO1xuICAgIF90aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgICBnZW9Kc29uOiBnZW9Kc29uLFxuICAgICAgcmFkaXVzOiByYWRpdXMsXG4gICAgICByZXNvbHV0aW9uOiByZXNvbHV0aW9uXG4gICAgfTtcblxuICAgIC8vIHByb2Nlc3MgdmFyaW91cyBnZW9tZXRyeSB0eXBlc1xuICAgIHZhciBncm91cHMgPSAoe1xuICAgICAgUG9pbnQ6IGdlblBvaW50LFxuICAgICAgTXVsdGlQb2ludDogZ2VuTXVsdGlQb2ludCxcbiAgICAgIExpbmVTdHJpbmc6IGdlbkxpbmVTdHJpbmcsXG4gICAgICBNdWx0aUxpbmVTdHJpbmc6IGdlbk11bHRpTGluZVN0cmluZyxcbiAgICAgIFBvbHlnb246IGdlblBvbHlnb24sXG4gICAgICBNdWx0aVBvbHlnb246IGdlbk11bHRpUG9seWdvblxuICAgIH1bZ2VvSnNvbi50eXBlXSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfSkoZ2VvSnNvbi5jb29yZGluYXRlcywgcmFkaXVzKTtcblxuICAgIC8vIGNvbmNhdCBncm91cHNcbiAgICB2YXIgaW5kaWNlcyA9IFtdLFxuICAgICAgdmVydGljZXMgPSBbXTtcbiAgICB2YXIgZ3JvdXBDbnQgPSAwO1xuICAgIGdyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uIChuZXdHKSB7XG4gICAgICB2YXIgcHJldkluZENudCA9IGluZGljZXMubGVuZ3RoO1xuICAgICAgY29uY2F0R3JvdXAoe1xuICAgICAgICBpbmRpY2VzOiBpbmRpY2VzLFxuICAgICAgICB2ZXJ0aWNlczogdmVydGljZXNcbiAgICAgIH0sIG5ld0cpO1xuICAgICAgX3RoaXMuYWRkR3JvdXAocHJldkluZENudCwgaW5kaWNlcy5sZW5ndGggLSBwcmV2SW5kQ250LCBncm91cENudCsrKTtcbiAgICB9KTtcblxuICAgIC8vIGJ1aWxkIGdlb21ldHJ5XG4gICAgaW5kaWNlcy5sZW5ndGggJiYgX3RoaXMuc2V0SW5kZXgoaW5kaWNlcyk7XG4gICAgdmVydGljZXMubGVuZ3RoICYmIF90aGlzW3NldEF0dHJpYnV0ZUZuXSgncG9zaXRpb24nLCBuZXcgVEhSRUUuRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSh2ZXJ0aWNlcywgMykpO1xuXG4gICAgLy9cblxuICAgIGZ1bmN0aW9uIGdlblBvaW50KGNvb3Jkcywgcikge1xuICAgICAgdmFyIHZlcnRpY2VzID0gcG9sYXIyQ2FydGVzaWFuKGNvb3Jkc1sxXSwgY29vcmRzWzBdLCByKTtcbiAgICAgIHZhciBpbmRpY2VzID0gW107XG4gICAgICByZXR1cm4gW3tcbiAgICAgICAgdmVydGljZXM6IHZlcnRpY2VzLFxuICAgICAgICBpbmRpY2VzOiBpbmRpY2VzXG4gICAgICB9XTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2VuTXVsdGlQb2ludChjb29yZHMsIHIpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgIHZlcnRpY2VzOiBbXSxcbiAgICAgICAgaW5kaWNlczogW11cbiAgICAgIH07XG4gICAgICBjb29yZHMubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBnZW5Qb2ludChjLCByKTtcbiAgICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgdmFyIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMSksXG4gICAgICAgICAgbmV3UG50ID0gX3JlZjJbMF07XG4gICAgICAgIGNvbmNhdEdyb3VwKHJlc3VsdCwgbmV3UG50KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFtyZXN1bHRdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZW5MaW5lU3RyaW5nKGNvb3Jkcywgcikge1xuICAgICAgdmFyIGNvb3JkczNkID0gaW50ZXJwb2xhdGVMaW5lKGNvb3JkcywgcmVzb2x1dGlvbikubWFwKGZ1bmN0aW9uIChfcmVmMykge1xuICAgICAgICB2YXIgX3JlZjQgPSBfc2xpY2VkVG9BcnJheShfcmVmMywgMiksXG4gICAgICAgICAgbG5nID0gX3JlZjRbMF0sXG4gICAgICAgICAgbGF0ID0gX3JlZjRbMV07XG4gICAgICAgIHJldHVybiBwb2xhcjJDYXJ0ZXNpYW4obGF0LCBsbmcsIHIpO1xuICAgICAgfSk7XG4gICAgICB2YXIgX2VhcmN1dEZsYXR0ZW4gPSBmbGF0dGVuKFtjb29yZHMzZF0pLFxuICAgICAgICB2ZXJ0aWNlcyA9IF9lYXJjdXRGbGF0dGVuLnZlcnRpY2VzO1xuICAgICAgdmFyIG51bVBvaW50cyA9IE1hdGgucm91bmQodmVydGljZXMubGVuZ3RoIC8gMyk7XG4gICAgICB2YXIgaW5kaWNlcyA9IFtdO1xuICAgICAgZm9yICh2YXIgdklkeCA9IDE7IHZJZHggPCBudW1Qb2ludHM7IHZJZHgrKykge1xuICAgICAgICBpbmRpY2VzLnB1c2godklkeCAtIDEsIHZJZHgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFt7XG4gICAgICAgIHZlcnRpY2VzOiB2ZXJ0aWNlcyxcbiAgICAgICAgaW5kaWNlczogaW5kaWNlc1xuICAgICAgfV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdlbk11bHRpTGluZVN0cmluZyhjb29yZHMsIHIpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgIHZlcnRpY2VzOiBbXSxcbiAgICAgICAgaW5kaWNlczogW11cbiAgICAgIH07XG4gICAgICBjb29yZHMubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBnZW5MaW5lU3RyaW5nKGMsIHIpO1xuICAgICAgfSkuZm9yRWFjaChmdW5jdGlvbiAoX3JlZjUpIHtcbiAgICAgICAgdmFyIF9yZWY2ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjUsIDEpLFxuICAgICAgICAgIG5ld0xpbmUgPSBfcmVmNlswXTtcbiAgICAgICAgY29uY2F0R3JvdXAocmVzdWx0LCBuZXdMaW5lKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFtyZXN1bHRdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZW5Qb2x5Z29uKGNvb3Jkcywgcikge1xuICAgICAgdmFyIGNvb3JkczNkID0gY29vcmRzLm1hcChmdW5jdGlvbiAoY29vcmRzU2VnbWVudCkge1xuICAgICAgICByZXR1cm4gaW50ZXJwb2xhdGVMaW5lKGNvb3Jkc1NlZ21lbnQsIHJlc29sdXRpb24pLm1hcChmdW5jdGlvbiAoX3JlZjcpIHtcbiAgICAgICAgICB2YXIgX3JlZjggPSBfc2xpY2VkVG9BcnJheShfcmVmNywgMiksXG4gICAgICAgICAgICBsbmcgPSBfcmVmOFswXSxcbiAgICAgICAgICAgIGxhdCA9IF9yZWY4WzFdO1xuICAgICAgICAgIHJldHVybiBwb2xhcjJDYXJ0ZXNpYW4obGF0LCBsbmcsIHIpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBFYWNoIHBvaW50IGdlbmVyYXRlcyAzIHZlcnRpY2UgaXRlbXMgKHgseSx6KS5cbiAgICAgIHZhciBfZWFyY3V0RmxhdHRlbjIgPSBmbGF0dGVuKGNvb3JkczNkKSxcbiAgICAgICAgdmVydGljZXMgPSBfZWFyY3V0RmxhdHRlbjIudmVydGljZXMsXG4gICAgICAgIGhvbGVzID0gX2VhcmN1dEZsYXR0ZW4yLmhvbGVzO1xuICAgICAgdmFyIGZpcnN0SG9sZUlkeCA9IGhvbGVzWzBdIHx8IEluZmluaXR5O1xuICAgICAgdmFyIG91dGVyVmVydGljZXMgPSB2ZXJ0aWNlcy5zbGljZSgwLCBmaXJzdEhvbGVJZHggKiAzKTtcbiAgICAgIHZhciBob2xlVmVydGljZXMgPSB2ZXJ0aWNlcy5zbGljZShmaXJzdEhvbGVJZHggKiAzKTtcbiAgICAgIHZhciBob2xlc0lkeCA9IG5ldyBTZXQoaG9sZXMpO1xuICAgICAgdmFyIG51bVBvaW50cyA9IE1hdGgucm91bmQodmVydGljZXMubGVuZ3RoIC8gMyk7XG4gICAgICB2YXIgb3V0ZXJJbmRpY2VzID0gW10sXG4gICAgICAgIGhvbGVJbmRpY2VzID0gW107XG4gICAgICBmb3IgKHZhciB2SWR4ID0gMTsgdklkeCA8IG51bVBvaW50czsgdklkeCsrKSB7XG4gICAgICAgIGlmICghaG9sZXNJZHguaGFzKHZJZHgpKSB7XG4gICAgICAgICAgaWYgKHZJZHggPCBmaXJzdEhvbGVJZHgpIHtcbiAgICAgICAgICAgIG91dGVySW5kaWNlcy5wdXNoKHZJZHggLSAxLCB2SWR4KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaG9sZUluZGljZXMucHVzaCh2SWR4IC0gMSAtIGZpcnN0SG9sZUlkeCwgdklkeCAtIGZpcnN0SG9sZUlkeCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgZ3JvdXBzID0gW3tcbiAgICAgICAgaW5kaWNlczogb3V0ZXJJbmRpY2VzLFxuICAgICAgICB2ZXJ0aWNlczogb3V0ZXJWZXJ0aWNlc1xuICAgICAgfV07XG4gICAgICBpZiAoaG9sZXMubGVuZ3RoKSB7XG4gICAgICAgIGdyb3Vwcy5wdXNoKHtcbiAgICAgICAgICBpbmRpY2VzOiBob2xlSW5kaWNlcyxcbiAgICAgICAgICB2ZXJ0aWNlczogaG9sZVZlcnRpY2VzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdyb3VwcztcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2VuTXVsdGlQb2x5Z29uKGNvb3Jkcywgcikge1xuICAgICAgdmFyIG91dGVyID0ge1xuICAgICAgICB2ZXJ0aWNlczogW10sXG4gICAgICAgIGluZGljZXM6IFtdXG4gICAgICB9O1xuICAgICAgdmFyIGhvbGVzID0ge1xuICAgICAgICB2ZXJ0aWNlczogW10sXG4gICAgICAgIGluZGljZXM6IFtdXG4gICAgICB9O1xuICAgICAgY29vcmRzLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gZ2VuUG9seWdvbihjLCByKTtcbiAgICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKF9yZWY5KSB7XG4gICAgICAgIHZhciBfcmVmMTAgPSBfc2xpY2VkVG9BcnJheShfcmVmOSwgMiksXG4gICAgICAgICAgbmV3T3V0ZXIgPSBfcmVmMTBbMF0sXG4gICAgICAgICAgbmV3SG9sZXMgPSBfcmVmMTBbMV07XG4gICAgICAgIGNvbmNhdEdyb3VwKG91dGVyLCBuZXdPdXRlcik7XG4gICAgICAgIG5ld0hvbGVzICYmIGNvbmNhdEdyb3VwKGhvbGVzLCBuZXdIb2xlcyk7XG4gICAgICB9KTtcbiAgICAgIHZhciBncm91cHMgPSBbb3V0ZXJdO1xuICAgICAgaG9sZXMudmVydGljZXMubGVuZ3RoICYmIGdyb3Vwcy5wdXNoKGhvbGVzKTtcbiAgICAgIHJldHVybiBncm91cHM7XG4gICAgfVxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBfaW5oZXJpdHMoR2VvSnNvbkdlb21ldHJ5LCBfVEhSRUUkQnVmZmVyR2VvbWV0cnkpO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKEdlb0pzb25HZW9tZXRyeSk7XG59KFRIUkVFLkJ1ZmZlckdlb21ldHJ5KTsgLy9cbmZ1bmN0aW9uIGNvbmNhdEdyb3VwKG1haW4sIGV4dHJhKSB7XG4gIHZhciBwcmV2VmVydENudCA9IE1hdGgucm91bmQobWFpbi52ZXJ0aWNlcy5sZW5ndGggLyAzKTtcbiAgY29uY2F0QXJyKG1haW4udmVydGljZXMsIGV4dHJhLnZlcnRpY2VzKTtcbiAgY29uY2F0QXJyKG1haW4uaW5kaWNlcywgZXh0cmEuaW5kaWNlcy5tYXAoZnVuY3Rpb24gKGluZCkge1xuICAgIHJldHVybiBpbmQgKyBwcmV2VmVydENudDtcbiAgfSkpO1xufVxuZnVuY3Rpb24gY29uY2F0QXJyKHRhcmdldCwgc3JjKSB7XG4gIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihzcmMpLFxuICAgIF9zdGVwO1xuICB0cnkge1xuICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgZSA9IF9zdGVwLnZhbHVlO1xuICAgICAgdGFyZ2V0LnB1c2goZSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3IuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvci5mKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBvbGFyMkNhcnRlc2lhbihsYXQsIGxuZykge1xuICB2YXIgciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcbiAgdmFyIHBoaSA9ICg5MCAtIGxhdCkgKiBNYXRoLlBJIC8gMTgwO1xuICB2YXIgdGhldGEgPSAoOTAgLSBsbmcpICogTWF0aC5QSSAvIDE4MDtcbiAgcmV0dXJuIFtyICogTWF0aC5zaW4ocGhpKSAqIE1hdGguY29zKHRoZXRhKSxcbiAgLy8geFxuICByICogTWF0aC5jb3MocGhpKSxcbiAgLy8geVxuICByICogTWF0aC5zaW4ocGhpKSAqIE1hdGguc2luKHRoZXRhKSAvLyB6XG4gIF07XG59XG5cbmV4cG9ydCB7IEdlb0pzb25HZW9tZXRyeSB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-geojson-geometry/dist/three-geojson-geometry.mjs\n");

/***/ })

};
;